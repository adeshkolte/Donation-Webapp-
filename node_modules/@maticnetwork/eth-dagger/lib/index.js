"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _asyncMqtt = _interopRequireDefault(require("async-mqtt"));

var _events = _interopRequireDefault(require("events"));

var _mqttRegex = _interopRequireDefault(require("./mqtt-regex"));

var _room = _interopRequireDefault(require("./room"));

var _contract = _interopRequireDefault(require("./contract"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var ROOMS = ['latest', 'confirmed'];

var Dagger = /*#__PURE__*/function (_EventEmitter) {
  _inherits(Dagger, _EventEmitter);

  var _super = _createSuper(Dagger);

  function Dagger(url) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Dagger);

    _this = _super.call(this);

    if (!url || url instanceof String) {
      throw new Error('`url` (string) is required as first argument');
    } // set params


    _this.url = url;
    _this.options = options; // event params

    _this._regexTopics = {}; // mqtt client

    _this._client = _asyncMqtt["default"].connect(url, options);
    _this._clientConnectPromise = new Promise(function (resolve) {
      _this._client.on('connect', function () {
        if (_this._clientConnectPromise && !_this._clientConnectPromise.resolved) {
          _this._clientConnectPromise.resolved = true;
          resolve.apply(void 0, arguments);
        }
      });

      _this._client.on('reconnect', function () {
        console.log('reconnecting...');
      });
    }); // mqtt client events

    _this._client.on('message', _this._onMessage.bind(_assertThisInitialized(_this)));

    ['Connect', 'Reconnect', 'Offline', 'Close', 'Error'].forEach(function (name) {
      _this._client.on(name.toLowerCase(), _this["_on".concat(name)].bind(_assertThisInitialized(_this)));
    });
    return _this;
  }

  _createClass(Dagger, [{
    key: "_onMessage",
    value: function _onMessage(topic, data) {
      var _this2 = this;

      var payload = data.toString();

      try {
        payload = JSON.parse(payload);
      } catch (e) {
        payload = {};
      } // get matching topics


      this.emit('message', payload);
      this.getMatchingTopics(topic).forEach(function (eventName) {
        _this2.emit(eventName, payload.data, !!payload.removed, payload);
      });
    }
  }, {
    key: "_onConnect",
    value: function _onConnect() {
      this._changeConnectionStatus(true);
    }
  }, {
    key: "_onReconnect",
    value: function _onReconnect() {
      this.emit('reconnect', this);
    }
  }, {
    key: "_onOffline",
    value: function _onOffline() {
      this._changeConnectionStatus(false);
    }
  }, {
    key: "_onClose",
    value: function _onClose() {
      this._changeConnectionStatus(false);
    }
  }, {
    key: "_onError",
    value: function _onError(error) {
      this.emit('error', error);
    }
    /**
     * close - close connection
     *
     * @returns {Promise} promise - close connection promise
     * @param {Boolean} force - do not wait for all in-flight messages to be acked
     *
     * @api public
     */

  }, {
    key: "close",
    value: function close(force) {
      return this._client.end(force);
    } //
    // connection promise
    //

    /**
     * onceConnected - connection promise
     *
     * @returns {Promise} promise - connection promise
     *
     * @api public
     */

  }, {
    key: "onceConnected",
    value: function onceConnected() {
      return this._clientConnectPromise;
    } //
    // core logic
    //

  }, {
    key: "on",
    value: function on() {
      return this.addListener.apply(this, arguments);
    }
  }, {
    key: "addListener",
    value: function addListener(eventName, listener) {
      var mqttRegex = new _mqttRegex["default"](eventName);

      if (!this._regexTopics[mqttRegex.topic]) {
        // subscribe events from server using topic
        this._client.subscribe(mqttRegex.topic);
      } // add to listeners using super


      _get(_getPrototypeOf(Dagger.prototype), "addListener", this).call(this, mqttRegex.topic, listener);

      this._regexTopics[mqttRegex.topic] = mqttRegex;
      return this;
    }
  }, {
    key: "prependListener",
    value: function prependListener(eventName, listener) {
      var mqttRegex = new _mqttRegex["default"](eventName);

      if (!this._regexTopics[mqttRegex.topic]) {
        // subscribe events from server using topic
        this._client.subscribe(mqttRegex.topic);
      } // add to listeners using super


      _get(_getPrototypeOf(Dagger.prototype), "prependListener", this).call(this, mqttRegex.topic, listener);

      this._regexTopics[mqttRegex.topic] = mqttRegex;
      return this;
    }
  }, {
    key: "off",
    value: function off() {
      return this.removeListener.apply(this, arguments);
    }
  }, {
    key: "removeListener",
    value: function removeListener(eventName, listener) {
      var mqttRegex = new _mqttRegex["default"](eventName); // add to listeners using super

      _get(_getPrototypeOf(Dagger.prototype), "removeListener", this).call(this, mqttRegex.topic, listener); // if listener count is zero, unsubscribe topic and delete from `_regexTopics`


      if (this.listenerCount(mqttRegex.topic) === 0) {
        // unsubscribe events from server
        this._client.unsubscribe(mqttRegex.topic);

        delete this._regexTopics[mqttRegex.topic];
      }

      return this;
    }
  }, {
    key: "removeAllListeners",
    value: function removeAllListeners(eventName) {
      var mqttRegex = new _mqttRegex["default"](eventName); // unsubscribe events from server

      this._client.unsubscribe(mqttRegex.topic); // add to listeners using super


      _get(_getPrototypeOf(Dagger.prototype), "removeAllListeners", this).call(this, mqttRegex.topic);

      delete this._regexTopics[mqttRegex.topic];
      return this;
    }
  }, {
    key: "getMatchingTopics",
    value: function getMatchingTopics(eventName) {
      var _this3 = this;

      var matching = [];
      Object.keys(this._regexTopics).forEach(function (key) {
        var me = _this3._regexTopics[key];

        if (me && me.exec(eventName)) {
          matching.push(me.topic);
        }
      });
      return matching;
    }
  }, {
    key: "getSubscriptions",
    value: function getSubscriptions() {
      return Object.keys(this._regexTopics);
    } //
    // Connection status
    //

    /**
     * Get connnection status
     *
     * @returns {Boolean} status - connection status
     *
     * @api public
     */

  }, {
    key: "connectionStatus",
    value: function connectionStatus() {
      return !!this._changeConnectionStatus._v;
    }
    /**
     * _changeConnectionStatus - connection statu change (internal method)
     */

  }, {
    key: "_changeConnectionStatus",
    value: function _changeConnectionStatus(value) {
      if (value !== this._changeConnectionStatus._v) {
        this._changeConnectionStatus._v = value;
        this.emit('connection.status', value);
      }
    } //
    // Room related stuff
    //

    /**
     * Select room for events: chainable
     */

  }, {
    key: "of",
    value: function of(room) {
      var cleanRoom = room && room.toLowerCase();

      if (!cleanRoom || ROOMS.indexOf(cleanRoom) === -1) {
        throw new Error("Room must be one of these: ".concat(ROOMS.join(', ')));
      }

      return new _room["default"](this, cleanRoom);
    } //
    // Web3 stuff
    //

    /**
     * Contract injector
     */

  }, {
    key: "contract",
    value: function contract(c) {
      return new _contract["default"](this, c);
    }
  }]);

  return Dagger;
}(_events["default"]);

exports["default"] = Dagger;
module.exports = exports.default;
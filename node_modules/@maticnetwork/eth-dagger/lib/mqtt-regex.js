"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _escapeStringRegexp = _interopRequireDefault(require("escape-string-regexp"));

var _ethereumjsUtil = require("ethereumjs-util");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

//
// Inspired from mqtt-regex (from RangerMauve) https://github.com/RangerMauve/mqtt-regex
//
// Mqtt Regexp
var MqttRegex = /*#__PURE__*/function () {
  function MqttRegex(rawTopic) {
    _classCallCheck(this, MqttRegex);

    var topic = rawTopic.toLowerCase(); // tokens

    var tokens = MqttRegex.tokanize(topic); // set params

    this.topic = tokens.join('/');
    this.rawTopic = topic;
    this.regex = MqttRegex.makeRegex(tokens.map(MqttRegex.processToken));
    this.exec = this.exec.bind(this);
  }

  _createClass(MqttRegex, [{
    key: "exec",
    value: function exec(rawTopic) {
      var topic = rawTopic.toLowerCase();
      return this.regex.exec(topic);
    }
  }], [{
    key: "tokanize",
    value: function tokanize(rawTopic) {
      var topic = rawTopic.toLowerCase();
      var tokens = topic.split('/');

      if (tokens.length >= 4 && tokens[0].includes(':log')) {
        for (var i = 4; i < tokens.length; i++) {
          if (tokens[i] !== '+' && tokens[i] !== '#') {
            tokens[i] = (0, _ethereumjsUtil.bufferToHex)((0, _ethereumjsUtil.setLengthLeft)((0, _ethereumjsUtil.addHexPrefix)(tokens[i]), 32));
          }
        }
      }

      return tokens;
    }
  }, {
    key: "makeRegex",
    value: function makeRegex(tokens) {
      var lastToken = tokens[tokens.length - 1];
      var regexTokens = tokens.map(function (token, index) {
        var isLast = lastToken === token;
        var beforeMulti = index === tokens.length - 2 && lastToken.type === 'multi';
        return isLast || beforeMulti ? token.last : token.piece;
      });
      return new RegExp("^".concat(regexTokens.join(''), "$"));
    }
  }, {
    key: "processToken",
    value: function processToken(token, index, tokens) {
      var last = index === tokens.length - 1;

      if (!token || token.trim().length === 0) {
        throw new Error('Topic must not be empty in pattern path.');
      } // trim token


      var cleanToken = token.trim();

      if (cleanToken[0] === '+') {
        return {
          type: 'single',
          name: '',
          piece: '([^/#+]+/)',
          last: '([^/#+]+/?)'
        };
      } else if (cleanToken[0] === '#') {
        if (!last) {
          throw new Error('# wildcard must be at the end of the pattern');
        }

        return {
          type: 'multi',
          name: '#',
          piece: '((?:[^/#+]+/)*)',
          last: '((?:[^/#+]+/?)*)'
        };
      }

      var escapedToken = (0, _escapeStringRegexp["default"])(cleanToken);
      return {
        type: 'raw',
        name: token,
        // changed from mqtt-regex (RangerMauve)
        piece: "".concat(escapedToken, "/"),
        last: "".concat(escapedToken, "/?")
      };
    }
  }]);

  return MqttRegex;
}();

exports["default"] = MqttRegex;
module.exports = exports.default;
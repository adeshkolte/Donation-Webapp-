"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// private watch
var _watch = function _watch(subscription, method, c) {
  if (!c) {
    throw new Error('callback is required!');
  }

  if (subscription.callback) {
    return subscription;
  }

  subscription.callback = function (log) {
    // eslint-disable-line no-param-reassign
    var event = subscription._eventOptions.event;
    var clonedLog = JSON.parse(JSON.stringify(log));

    var parsedLog = subscription.contract._decodeEventABI.call(event, clonedLog);

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    c.apply(void 0, [parsedLog].concat(args));
  };

  subscription.dagger[method](subscription.route, subscription.callback);
  return subscription;
};
/**
 * Event subscription
 */


var EventSubscription = /*#__PURE__*/function () {
  function EventSubscription(dagger, contract, name) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    _classCallCheck(this, EventSubscription);

    this.dagger = dagger;
    this.contract = contract;
    this.name = name;
    this.options = options; // set room

    this.options.room = this.options.room || 'latest';
    this.options.filter = this.options.filter || {}; // get event options

    this._eventOptions = this.contract._generateEventOptions(this.name, this.options); // build topics

    var topics = this._eventOptions.params.topics;

    if (topics && topics.length > 0) {
      topics = topics.map(function (t) {
        return (t || '+').toLowerCase();
      });
    } else {
      // for all events
      topics = ['#'];
    } // set route


    var address = this.contract.options.address.toLowerCase();
    this.route = "".concat(this.options.room, ":log/").concat(address, "/filter/").concat(topics.join('/'));
  }

  _createClass(EventSubscription, [{
    key: "watch",
    value: function watch(fn) {
      return _watch(this, 'on', fn);
    }
  }, {
    key: "watchOnce",
    value: function watchOnce(fn) {
      return _watch(this, 'once', fn);
    }
  }, {
    key: "stopWatching",
    value: function stopWatching() {
      if (!this.callback) {
        return this;
      }

      this.dagger.off(this.route, this.callback);
      this.callback = null;
      return this;
    }
  }]);

  return EventSubscription;
}();
/**
 * @file contract.js
 *
 * To initialize a contract use:
 *
 *  var contract = new dagger.Contract(dagger, web3Contract);
 */


var Contract = /*#__PURE__*/function () {
  function Contract(dagger, contract) {
    _classCallCheck(this, Contract);

    // events
    this.events = {}; // set properties

    this.dagger = dagger;
    this.contract = contract;
  }

  _createClass(Contract, [{
    key: "subscription",
    value: function subscription(name, options) {
      if (!this.contract.options.address) {
        throw new Error('contract address is required for subscription');
      }

      return new EventSubscription(this.dagger, this.contract, name, options);
    }
  }, {
    key: "contract",
    set: function set(value) {
      var _this = this;

      this._contract = value; // events

      Object.keys(this._contract.events).forEach(function (name) {
        _this.events[name] = _this.subscription.bind(_this, name); // storing old subscription (in case)

        _this.events[name]._oldSubscription = _this._contract.events[name];
      });
    },
    get: function get() {
      return this._contract;
    }
  }]);

  return Contract;
}();

exports["default"] = Contract;
module.exports = exports.default;